头文件重复包含的问题
---
&emsp;由Windows转到Linux，然后突然想到头文件重复包含的问题，由于在Windows下的VS编译环境中，有一个宏#pragma once可以保证头文件纸杯编译一次，不会出现重复定义的问题，但是这是一个杂注，与平台和和编译器有关，所以一般为了能够跨平台都不会使用这个杂注，而是使用C/C++的预编译命令：#ifndef,#define,#endif进行相应的保护。

#1.有文件内的内容
&emsp;在开始思考这个问题的时候，我最先想的是我们的头文件内应该写一些什么呢，最直接的反应就是头文件内因该是各种申明，包括类，全局函数，结构体，枚举，全局变量等各种，但实际上也是如此，但对于头文件内不仅仅如此，在头文件内不仅可以进行申明，还可以定义，所有c或者是cpp文件内可以做的东西他都可以做。

&emsp;但是为代码的维护、规范以及可阅读性等等，一般在头文件内只有申明，没有定义。主要包括各种数据结构，宏，全局函数，全局变量，类的声明。但是如果细心的话，你可能会发现，在C库的头文件内不仅仅有函数的声明，还会有函数的定义，其实这是针对某些功能简单的函数，方便阅读和实现。

&emsp;一般在C++项目中，头文件和相应的cpp文件都是有对应关系的，我们一般将类的申明放在h文件中，在对应的cpp文件中，进行类的接口的定义，静态成员的初始化等。同事我们也可以定义一些我们需要的数据结构，如结构体，枚举等，但是为了方便管理，我们一般将类的声明和数据结构的声明分开在不同的文件中，也就是，我们将在一个或者多个头文件内专门用来定义我们需要的数据结构，在需要的地方再去包含相应的头文件。

#2.头文件重复包含的问题
&emsp;当多个cpp文件都包含同一个头文件的时候，就会出现重复定义的问题(只有定义会有重复的问题，申明是不会有重复的问题），也就是说只有函数声明的的头文件是不会存在重复的问题，只有在有数据结构定义，全局变量的头文件才会有这个问题，对于一般情况的，将头文件用一个预编译和宏定义就可以解决该问。如下所示：

	#test.h
	#ifndef _TEST_H_
	#define _TEST_H_
	class test
	{
	...,
	};
	#endif
此时，这个头文件,不管你如何使用都是没问题的。
#3.全局变量
&emsp;刚好，项目的需要，定义了一个全局变量iIndex在上面的头文件内，大概效果如下：

	#test.h
	#ifndef _TEST_H_
	#define _TEST_H_
	int iIndex;
	class test
	{
	...,
	};
	#endif
那么，此时如果你多个地方包含了该头文件，那么重复定义的问题又出现了.

why????

此时，不得不好好思考这个问题的本质了，首先头文件在整个过程中扮演一个什么样的角色？我们在编译的时候酒精干了些什么？
探究一下编译的过程：编译一般分为四个阶段：
##3.1预处理阶段
&emsp;该阶段预处理器会处理以#开头的命令（如#include，#define，#if等），处理之后的输出文件就完全是个纯C++源文件，不再包含预处理命令，当该处理过程将根据#if，#ifdef，#ifndef，#endif来确定是否需要时行相应的处理。其中#include命令中包含的头文件会被替换成相应的文件内容，但通常只是声明，实现部分可能依然在源文件中，但会以特殊标记标出，以便编译器可以找到相应的实现。对于#define定义的宏命令，会直接进行相应内容的替换。
&emsp；